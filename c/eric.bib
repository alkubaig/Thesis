% Journals
@string{JFP    = {{Journal of Functional Programming (JFP)}}}
@string{JVLC   = {{Journal of Visual Languages and Computing (JVLC)}}}
@string{TOPLAS = {{ACM Trans.\ on Programming Languages and Systems (TOPLAS)}}}
@string{TOSEM  = {{ACM Trans.\ on Software Engineering and Methodology (TOSEM)}}}
@string{PACMPL = {{Proc.\ of the ACM on Programming Languages (PACMPL)}}}

% Conferences
@string{DSL    = {{IFIP Working Conf.\ on Domain-Specific Languages (DSL)}}}
@string{DTM    = {{ASME Int.\ Design Engineering Technical Conf.\ \& Computers and Information in Engineering Conf. (IDETC/CIE)}}}
@string{ECOOP  = {{European Conf.\ on Object-Oriented Programming (ECOOP)}}}
@string{GPCE   = {{ACM SIGPLAN Int.\ Conf.\ on Generative Programming: Concepts and Experiences (GPCE)}}}
@string{ICFP   = {{ACM SIGPLAN Int.\ Conf.\ on Functional Programming (ICFP)}}}
@string{ICSME  = {{IEEE Int.\ Conf.\ on Software Maintenance and Evolution (ICSME)}}}
@string{Onward = {{ACM SIGPLAN Symp.\ on New Ideas in Programming and Reflections on Software (Onward!)}}}
@string{POPL   = {{ACM SIGPLAN Symp.\ on Principles of Programming Languages (POPL)}}}
@string{PPDP   = {{ACM SIGPLAN Int.\ Symp.\ on Principles and Practice of Declarative Programming (PPDP)}}}
@string{SIGCSE = {{ACM SIGCSE Technical Symp.\ on Computer Science Education (SIGCSE)}}}
@string{SLE    = {{ACM SIGPLAN Int.\ Conf.\ on Software Language Engineering (SLE)}}}
@string{VLHCC  = {{IEEE Int.\ Symp.\ on Visual Languages and Human-Centric Computing (VL/HCC)}}}

% Workshops
@string{DBPL   = {{Int.\ Symp.\ on Database Programming Languages (DBPL)}}}
@string{FOSD   = {{Int.\ Work.\ on Feature-Oriented Software Development (FOSD)}}}
@string{FoSER  = {{ACM SIGSOFT Workshop on the Future of Software Engineering Research}}}
@string{Mutation = {{Int.\ Work.\ on Mutation Analysis (Mutation)}}}
@string{Poly   = {{VLDB Work.\ on Polystores and Other Systems for Heterogeneous Data}}}
@string{SETTA  = {{Symp.\ on Dependable Software Engineering: Theories, Tools and Applications (SETTA)}}}
@string{VaMoS  = {{Int.\ Work.\ on Variability Modelling of Software-Intensive Systems (VaMoS)}}}

% Series
@string{LNCS   = {{LNCS}}}
@string{LIPICS = {{LIPIcs}}}


%%%%%%%%%%
% Drafts %
%%%%%%%%%%

@misc{AVWdraft,
  author = {Abbott, Keeley and Van de Wetering, Miles and Walkingshaw, Eric},
  title = {{A Practical Plugin for View-Based Editing of Variational Code}},
  year = 2018,
  note = {Unpublished draft paper},
}


%%%%%%%%
% 2018 %
%%%%%%%%

@article{CCW18icfp,
  author    = {Campora III, John Peter and Chen, Sheng and Walkingshaw, Eric},
  title     = {{Casts and Costs: Harmonizing Safety and Performance in Gradual Typing}},
  journal   = PACMPL # { {\rm issue} } # ICFP,
  year      = 2018,
  kind      = {Journal},
  status    = {Accepted},
  rate      = {33\%},
  core      = {A*},
  note      = {To appear}
}

@inproceedings{ASW18ppdp,
  author    = {Adelsberger, Stephan and Setzer, Anton and Walkingshaw, Eric},
  title     = {{Declarative GUIs: Simple, Consistent, and Verified}},
  booktitle = PPDP,
  year      = 2018,
  kind      = {Conference},
  core      = {B},
  note      = {To appear}
}

@inproceedings{ASW18setta,
  author    = {Adelsberger, Stephan and Setzer, Anton and Walkingshaw, Eric},
  title     = {{Developing GUI Applications in a Verified Setting}},
  booktitle = SETTA,
  year      = 2018,
  kind      = {Workshop},
  core      = {N/A},
  note      = {To appear}
}

@inproceedings{ATW18poly,
  author    = {Ataei, Parisa and Termehchy, Arash and Walkingshaw, Eric},
  title     = {{Managing Structurally Heterogeneous Databases in Software Product Lines}},
  booktitle = Poly,
  year      = 2018,
  kind      = {Workshop},
  core      = {N/A},
  note      = {To appear}
}

@inproceedings{YW18sigcse,
  author    = {Young, Jeffrey and Walkingshaw, Eric},
  title     = {{A Domain Analysis of Data Structure and Algorithm Explanations in the Wild}},
  booktitle = SIGCSE,
  year      = 2018,
  pages     = {870--875},
  kind      = {Conference},
  status    = {Appeared},
  rate      = {35\%},
  core      = {A},
}

@article{CCEW18popl,
  author    = {Campora III, John Peter and Chen, Sheng and Erwig, Martin and Walkingshaw, Eric},
  title     = {{Migrating Gradual Types}},
  journal   = PACMPL # { {\rm issue} } # POPL,
  year      = 2018,
  volume    = 2,
  number    = 15,
  pages     = {15:1--15:29},
  kind      = {Journal},
  status    = {Appeared},
  rate      = {24\%},
  core      = {A*},
}


%%%%%%%%
% 2017 %
%%%%%%%%

@inproceedings{ATW17dbpl,
  author    = {Ataei, Parisa and Termehchy, Arash and Walkingshaw, Eric},
  title     = {{Variational Databases}},
  booktitle = DBPL,
  publisher = {ACM},
  year      = 2017,
  pages     = {11:1--11:4},
  kind      = {Workshop},
  status    = {Appeared},
  rate      = {67\%},
  core      = {B},
}

@inproceedings{GW17mutation,
  author    = {Gopinath, Rahul and Walkingshaw, Eric},
  title     = {{How Good are Your Types? Using Mutation Analysis to Evaluate the Effectiveness of Type Annotations}},
  booktitle = Mutation,
  publisher = {IEEE},
  year      = 2017,
  pages     = {122--127},
  note      = {\textbf{Best~presentation}},
  kind      = {Workshop},
  status    = {Appeared},
  rate      = {71\%},
  core      = {N/A},
}

@inproceedings{MMWWK17vamos,
  author    = {Meng, Meng and Meinicke, Jens and Wong, Chu-Pan and Walkingshaw, Eric and K\"{a}stner, Christian},
  title     = {{A Choice of Variational Stacks: Exploring Variational Data Structures}},
  booktitle = VaMoS,
  publisher = {ACM},
  year      = 2017,
  pages     = {28--35},
  kind      = {Workshop},
  status    = {Appeared},
  rate      = {38\%},
  core      = {N/A},
}

%%%%%%%%
% 2016 %
%%%%%%%%

@inproceedings{HW16fosd,
  author    = {Hubbard, Spencer and Walkingshaw, Eric},
  title     = {{Formula Choice Calculus}},
  booktitle = FOSD,
  publisher = {ACM},
  year      = 2016,
  pages     = {49--57},
  kind      = {Workshop},
  status    = {Appeared},
  rate      = {69\%},
  core      = {N/A},
}

@inproceedings{SBWW16icsme,
  author    = {St\u{a}nciulescu, Stefan and Berger, Thorsten and Walkingshaw, Eric and Andrzej W\k{a}sowski},
  title     = {{Concepts, Operations, and Feasibility of a Projection-Based Variation Control System}},
  booktitle = ICSME,
  year      = 2016,
  pages     = {323--333},
  kind      = {Conference},
  status    = {Appeared},
  rate      = {29\%},
  core      = {A},
}

@inproceedings{CEW16ecoop,
  author    = {Chen, Sheng and Erwig, Martin and Walkingshaw, Eric},
  title     = {{A Calculus for Variational Programming}},
  booktitle = ECOOP,
  series    = LIPICS,
  volume    = 56,
  year      = 2016,
  pages     = {6:1--6:26},
  kind      = {Conference},
  status    = {Appeared},
  rate      = {32\%},
  core      = {A},
}

%%%%%%%%
% 2015 %
%%%%%%%%

@inproceedings{ABW15vl,
  author    = {Abbott, Keeley and Bogart, Christopher and Walkingshaw, Eric},
  title     = {{Programs for People: What We Can Learn from Lab Protocols}},
  booktitle = VLHCC,
  year      = 2015,
  pages     = {203--211},
  kind      = {Conference},
  status    = {Appeared},
  rate      = {29\%},
  core      = {B},
  abstract  = {Humans play an active role in the execution of certain kinds of programs, such as spreadsheets, workflows, and interactive notebooks. Interacting closely with execution is especially useful when end-users are learning from examples while doing their work. In order to better understand the language features needed to support this kind of use, we investigated a particularly rigid and formalized category of “program” people write for each other: lab protocols. These protocols present a linear, idealized process despite the complex contingencies of the lab work they describe. However, they employ a variety of techniques for limiting or expanding the semantic interpretation of individual steps and for integrating outside protocols. We use these observations to derive implications for the design of interactive and mixed-initiative programming languages.}
}

%%%%%%%%
% 2014 %
%%%%%%%%

@inproceedings{Walk14onward,
  author    = {Walkingshaw, Eric and K\"{a}stner, Christian and Erwig, Martin and Apel, Sven and Bodden, Eric},
  title     = {{Variational Data Structures: Exploring Trade-Offs in Computing with Variability}},
  booktitle = Onward,
  year      = 2014,
  pages     = {213--226},
  kind      = {Conference},
  status    = {Appeared},
  rate      = {46\%},
  core      = {C},
  abstract  = {Variation is everywhere. Especially in the construction and analysis of customizable software, there arises a need for correspondingly variational data structures. So far, variational data structures have been explored and developed ad-hoc, as required for each individual use case. This perspective paper is a first attempt and a call to action for more systematic and foundational research in this area. We describe how support for variation can be understood as a general and orthogonal property of data types, data structures, and algorithms. We begin a systematic exploration of basic variational data structures, exploring the tradeoffs between different implementations. Finally, we retrospectively analyze the design decisions in our own previous work where we have independently encountered problems requiring variational data structures, and in the work of others who needed to represent and reason about variation.}
}

@inproceedings{WO14gpce,
  author    = {Walkingshaw, Eric and Ostermann, Klaus},
  title     = {{Projectional Editing of Variational Software}},
  booktitle = GPCE,
  year      = 2014,
  pages     = {29--38},
  note      = {\textbf{Best~paper}},
  kind      = {Conference},
  status    = {Appeared},
  rate      = {30\%},
  core      = {B},
  abstract  = {Editing the source code of variational software is complicated by the presence of variation annotations, such as \#ifdef statements, and by code that is only included in some configurations. When we want to edit some configurations and not others, it would be easier to edit a simplified version of the source code that contains only the variability we currently care about. In this paper, we present a projectional editing model for variational software. Using our approach, a programmer can partially configure a variational program, edit this simplified view of the code, and then automatically update the original, fully variational source code. The model is based on an isolation principle where edits affect only the variants that are visible in the view. We show that this principle has several nice properties that are suggested by related work on bidirectional transformations.},
}

@article{CEW14toplas,
  author    = {Chen, Sheng and Erwig, Martin and Walkingshaw, Eric},
  title     = {{Extending Type Inference to Variational Programs}},
  journal   = TOPLAS,
  year      = 2014,
  volume    = 36,
  number    = 1,
  pages     = {1:1--1:54},
  kind      = {Journal},
  status    = {Appeared},
  core      = {A*},
  abstract  = {Through the use of conditional compilation and related tools, many software projects can be used to generate a huge number of related programs. The problem of typing such variational software is difficult. The brute-force strategy of generating all variants and typing each one individually is (1) usually infeasible for efficiency reasons and (2) produces results that do not map well to the underlying variational program. Recent research has focused mainly on efficiency and addressed only the problem of type checking. In this work we tackle the more general problem of variational type inference and introduce variational types to represent the result of typing a variational program. We introduce the variational lambda calculus (VLC) as a formal foundation for research on typing variational programs. We define a type system for VLC in which VLC expressions are mapped to correspondingly variational types. We show that the type system is correct by proving that the typing of expressions is preserved over the process of variation elimination, which eventually results in a plain lambda calculus expression and its corresponding type. We identify a set of equivalence rules for variational types and prove that the type unification problem modulo these equivalence rules is unitary and decidable; we also present a sound and complete unification algorithm. Based on the unification algorithm, the variational type inference algorithm is an extension of algorithm W . We show that it is sound and complete and computes principal types. We also consider the extension of VLC with sum types, a necessary feature for supporting variational data types, and demonstrate that the previous theoretical results also hold under this extension. Finally, we characterize the complexity of variational type inference and demonstrate the efficiency gains over the brute-force strategy.}
}

%%%%%%%%
% 2013 %
%%%%%%%%

@inproceedings{EWC13fosd,
  author    = {Erwig, Martin and Walkingshaw, Eric and Chen, Sheng},
  title     = {{An Abstract Representation of Variational Graphs}},
  booktitle = FOSD,
  publisher = {ACM},
  year      = 2013,
  pages     = {25--32},
  kind      = {Workshop},
  status    = {Appeared},
  rate      = {69\%},
  core      = {N/A},
  abstract  = {In the context of software product lines, there is often a need to represent graphs containing variability. For example, extending traditional modeling techniques or program analyses to variational software requires a corresponding notion of variational graphs. But variational graphs are much more broadly useful and can be employed in many other applications outside of software product line analyses. To emphasize this generality we use a variational route-planning application as a motivating example throughout the paper. In this paper, we introduce a general model of variational graphs and a theoretical framework for discussing variational graph algorithms. Specifically, we present an abstract syntax based on tagging for succinctly representing variational graphs and other data types relevant to variational graph algorithms, such as variational sets and paths. We demonstrate how (non-variational) graph algorithms can be generalized to operate on variational graphs, to accept variational inputs, and produce variational outputs. Finally, we discuss a filtering operation on variational graphs and how this interacts with variational graph algorithms.}
}

@phdthesis{Walk13thesis,
  author   = {Walkingshaw, Eric},
  title    = {{The Choice Calculus: A Formal Language of Variation}},
  school   = {{Oregon State University}},
  year     = 2013,
  note     = {\url{http://hdl.handle.net/1957/40652}},
  kind     = {Thesis},
  status   = {Appeared},
  abstract = {In this thesis I present the choice calculus, a formal language for representing variation in software and other structured artifacts. The choice calculus is intended to support variation research in a way similar to the lambda calculus in programming language research. Specifically, it provides a simple formal basis for presenting, proving, and communicating theoretical results. It can serve as a common language of discourse for researchers working on different views of similar problems and provide a shared back end in tools. \\ This thesis collects a large amount of work on the choice calculus. It defines the syntax and denotational semantics of the language along with modular language extensions that add features important to variation research. It presents several theoretical results related to the choice calculus, such as an equivalence relation that supports semantics-preserving transformations of choice calculus expressions, and a type system for ensuring that an expression is well formed. It also presents a Haskell DSEL based on the choice calculus for exploring the concept of variational programming.}
}

@article{EW13jvlc,
  author    = {Erwig, Martin and Walkingshaw, Eric},
  title     = {{A Visual Language for Explaining Probabilistic Reasoning}},
  journal   = JVLC,
  publisher = {Elsevier},
  year      = 2013,
  volume    = 24,
  number    = 2,
  pages     = {88--109},
  kind      = {Journal},
  status    = {Appeared},
  core      = {A},
  abstract  = {We present an explanation-oriented, domain-specific, visual language for explaining probabilistic reasoning. Explanation-oriented programming is a new paradigm that shifts the focus of programming from the computation of results to explanations of how those results were computed. Programs in this language therefore describe explanations of probabilistic reasoning problems. The language relies on a storytelling metaphor of explanation, where the reader is guided through a series of well-understood steps from some initial state to the final result. Programs can also be manipulated according to a set of laws to automatically generate equivalent explanations from one explanation instance. This increases the explanatory value of the language by allowing readers to cheaply derive alternative explanations if they do not understand the first. The language is comprised of two parts: a formal textual notation for specifying explanation-producing programs and the more elaborate visual notation for presenting those explanations. We formally define the abstract syntax of explanations and define the semantics of the textual notation in terms of the explanations that are produced.}
}

@inproceedings{EORW13vamos,
  author    = {Erwig, Martin and Ostermann, Klaus and Rendel, Tillmann and Walkingshaw, Eric},
  title     = {{Adding Configuration to the Choice Calculus}},
  booktitle = VaMoS,
  publisher = {ACM},
  year      = 2013,
  pages     = {13:1--13:8},
  kind      = {Workshop},
  status    = {Appeared},
  rate      = {42\%},
  core      = {N/A},
  abstract  = {The choice calculus is a formal language for representing variation in software artifacts. Variability is organized in the choice calculus through the use of dimensions, where each dimension represents a decision that must be made in order to obtain a particular variant. However, the process of selecting alternatives from dimensions was relegated to an external operation. This precludes many interesting variation and reuse patterns, such as nested product lines, and theoretical results, such as a syntactic description of configuration, that would be possible if selection were a part of the language itself. \\ In this paper we add a selection operation to the choice calculus and illustrate how that increases the expressiveness of the calculus. We investigate some alternative semantics of this operation and study their impact and utility. Specifically, we will examine selection in the context of static and dynamically scoped dimension declarations, as a well as a modest and greedy form of dimension elimination. We also present a design for a type system to ensure configuration safety and modularity of nested product lines.}
}


%%%%%%%%
% 2012 %
%%%%%%%%

@inproceedings{WE12gpce,
  author    = {Walkingshaw, Eric and Erwig, Martin},
  title     = {{A Calculus for Modeling and Implementing Variation}},
  booktitle = {{ACM SIGPLAN Int.\ Conf.\ on Generative Programming and Component Engineering (GPCE)}},
  year      = 2012,
  pages     = {132--140},
  kind      = {Conference},
  status    = {Appeared},
  pdfname   = {CCC_GPCE12.pdf},
  rate      = {43\%},
  core      = {B},
  abstract  = {We present a formal calculus for modeling and implementing variation in software. It unifies the compositional and annotative approaches to feature implementation and supports the development of abstractions that can be used to directly relate feature models to their implementation. Since the compositional and annotative approaches are complementary, the calculus enables implementers to use the best combination of tools for the job and focus on inherent feature interactions, rather than those introduced by biases in the representation. The calculus also supports the abstraction of recurring variational patterns and provides a metaprogramming platform for organizing variation in artifacts.},
}

@inproceedings{CEW12icfp,
  author    = {Chen, Sheng and Erwig, Martin and Walkingshaw, Eric},
  title     = {{An Error-Tolerant Type System for Variational Lambda Calculus}},
  booktitle = ICFP,
  year      = 2012,
  pages     = {29--40},
  kind      = {Conference},
  status    = {Appeared},
  pdfname   = {VariTypes+Errors_ICFP12.pdf},
  rate      = {36\%},
  core      = {A*},
  abstract  = {Conditional compilation and software product line technologies make it possible to generate a huge number of different programs from a single software project. Typing each of these programs individually is usually impossible due to the sheer number of possible variants. Our previous work has addressed this problem with a type system for variational lambda calculus (VLC), an extension of lambda calculus with basic constructs for introducing and organizing variation. Although our type inference algorithm is more efficient than the brute-force strategy of inferring the types of each variant individually, it is less robust since type inference will fail for the entire variational expression if any one variant contains a type error. In this work, we extend our type system to operate on VLC expressions containing type errors. This extension directly supports locating ill-typed variants and the incremental development of variational programs. It also has many subtle implications for the unification of variational types. We show that our extended type system possesses a principal typing property and that the underlying unification problem is unitary. Our unification algorithm computes partial unifiers that lead to result types that (1) contain errors in as few variants as possible and (2) are most general. Finally, we perform an empirical evaluation to determine the overhead of this extension compared to our previous work, to demonstrate the improvements over the brute-force approach, and to explore the effects of various error distributions on the inference process.},
}

@incollection{EW12dsl,
  author    =	{Erwig, Martin and Walkingshaw, Eric},
  title     =	{{Semantics-Driven DSL Design}},
  booktitle =	{{Formal and Practical Aspects of Domain-Specific Languages: Recent Developments}},
  editor    = {Mernik, Marjan},
  pages     = {56--80},
  publisher = {IGI Global},
  year      = 2012,
  kind      = {Chapter},
  status    = {Appeared},
  rate      = {44\%},
  abstract  = {Convention dictates that the design of a language begins with its syntax. We argue that early emphasis should be placed instead on the identification of general, compositional semantic domains, and that grounding the design process in semantics leads to languages with more consistent and more extensible syntax.  We demonstrate this semantics-driven design process through the design and implementation of a DSL for defining and manipulating calendars, using Haskell as a metalanguage to support this discussion. We emphasize the importance of compositionality in semantics-driven language design, and describe a set of language operators that support an incremental and modular design process.},
}

%%%%%%%%
% 2011 %
%%%%%%%%

@mastersthesis{msthesis,
  author   = {Walkingshaw, Eric},
  title    = {{Domain-Specific Language Support for Experimental Game Theory}},
  school   = {{Oregon State University}},
  year     = 2011,
  note     = {\url{http://hdl.handle.net/1957/26757}},
  kind     = {Thesis},
  status   = {Appeared},
  abstract = {Experimental game theory is the use of game theoretic abstractions—games, players, and strategies—in experiments and simulations. It is often used in cases where traditional, analytical game theory fails or is difficult to apply. This thesis collects three previously published papers that provide domain-specific language (DSL) support for defining and executing these experiments, and for explaining their results. \\ Despite the widespread use of software in this field, there is a distinct lack of tool support for common tasks like modeling games and running simulations. Instead, most experiments are created from scratch in general-purpose programming languages. We have addressed this problem with Hagl, a DSL embedded in Haskell that allows the concise, declarative definition of games, strategies, and executable experiments. Hagl raises the level of abstraction for experimental game theory, reducing the effort to conduct experiments and freeing experimenters to focus on hard problems in their domain instead of low-level implementation details. \\ While analytical game theory is most often used as a prescriptive tool, a way to analyze a situation and determine the best course of action, experimental game theory is often applied descriptively to explain why agents interact and behave in a certain way. Often these interactions are complex and surprising. To support this explanatory role, we have designed visual DSL for explaining the interaction of strategies for iterated games. This language is used as a vehicle to introduce the notational quality of traceability and the new paradigm of explanation-oriented programming.}
}

@inproceedings{EW11gttse,
  author    = {Erwig, Martin and Walkingshaw, Eric},
  title     = {{Variation Programming with the Choice Calculus}},
  booktitle = {{Generative and Transformational Techniques in Software Engineering IV (GTTSE 2011), Revised and Extended Papers}},
  series    = LNCS,
  volume    = 7680,
  year      = 2013,
  pages     = {55--99},
  kind      = {Chapter},
  status    = {Appeared},
  core      = {N/A},
  abstract  = {The choice calculus provides a language for representing and transforming variation in software and other structured documents. Variability is captured in localized choices between alternatives. The space of all variations is organized by dimensions, which provide scoping and structure to choices. The variation space can be reduced through a process of selection, which eliminates a dimension and resolves all of its associated choices by replacing each with one of their alternatives. The choice calculus also allows the definition of arbitrary functions for the flexible construction and transformation of all kinds of variation structures. In this tutorial we will first present the motivation, general ideas, and principles that underlie the choice calculus. This is followed by a closer look at the semantics. We will then present practical applications based on several small example scenarios and consider the concepts of ``variation programming'' and ``variation querying''. The practical applications involve work with a Haskell library that supports variation programming and experimentation with the choice calculus.},
}

@inproceedings{LWE11vl,
  author    = {Le, Duc and Walkingshaw, Eric and Erwig, Martin},
  title     = {{\#ifdef Confirmed Harmful: Promoting Understandable Software Variation}},
  booktitle = VLHCC,
  year      = 2011,
  pages     = {143--150},
  kind      = {Conference},
  status    = {Appeared},
  rate      = {33\%},
  core      = {A},
  abstract  = {Maintaining variation in software is a difficult problem that poses serious challenges for the understanding and editing of software artifacts. Although the C preprocessor (CPP) is often the default tool used to introduce variability to software, because of its simplicity and flexibility, it is infamous for its obtrusive syntax and has been blamed for reducing the comprehensibility and maintainability of software. In this paper, we address this problem by developing a prototype for managing software variation at the source code level. We evaluate the difference between our prototype and CPP with a user study, which indicates that the prototype helps users reason about variational code faster and more accurately than CPP. Our results also support the research of others, providing evidence for the effectiveness of related tools, such as CIDE and FeatureCommander.},
}

@inproceedings{WE11dsl,
  author    = {Walkingshaw, Eric and Erwig, Martin},
  title     = {{A DSEL for Studying and Explaining Causation}},
  booktitle = DSL,
  year      = 2011,
  pages     = {143--167},
  kind      = {Conference},
  status    = {Appeared},
  rate      = {50\%},
  core      = {N/A},
  abstract  = {We present a domain-specific embedded language (DSEL) in Haskell that supports the philosophical study and practical explanation of causation. The language provides constructs for modeling situations comprised of events and functions for reliably determining the complex causal relationships that emerge between these events. It enables the creation of visual explanations of these causal relationships and a means to systematically generate alternative, related scenarios, along with corresponding outcomes and causes. The DSEL is based on neuron diagrams, a visual notation that is well established in practice and has been successfully employed for causation explanation and research. In addition to its immediate applicability by users of neuron diagrams, the DSEL is extensible, allowing causation experts to extend the notation to introduce special-purpose causation constructs. The DSEL also extends the notation of neuron diagrams to operate over non-boolean values, improving its expressiveness and offering new possibilities for causation research and its applications.},
}

@inproceedings{EW11sle,
  author    = {Erwig, Martin and Walkingshaw, Eric},
  title     = {{Semantics First! Rethinking the Language Design Process}},
  booktitle = SLE,
  series    = LNCS,
  volume    = 6940,
  year      = 2011,
  pages     = {243--262},
  kind      = {Conference},
  status    = {Appeared},
  rate      = {44\%},
  core      = {B},
  abstract  = {The design of languages is still more of an art than an engineering discipline. Although recently tools have been put forward to support the language design process, such as language workbenches, these have mostly focused on a syntactic view of languages. While these tools are quite helpful for the development of parsers and editors, they provide little support for the underlying design of the languages. In this paper we illustrate how to support the design of languages by focusing on their semantics first. Specifically, we will show that powerful and general language operators can be employed to adapt and grow sophisticated languages out of simple semantics concepts. We use Haskell as a metalanguage and will associate generic language concepts, such as semantics domains, with Haskell-specific ones, such as data types. We do this in a way that clearly distinguishes our approach to language design from the traditional syntax-oriented one. This will reveal some unexpected correlations, such as viewing type classes as language multipliers. We illustrate the viability of our approach with several real-world examples.},
}

@article{EW11tosem,
  author    = {Erwig, Martin and Walkingshaw, Eric},
  title     = {{The Choice Calculus: A Representation for Software Variation}},
  journal   = TOSEM,
  volume    = 21,
  number    = 1,
  year      = 2011,
  pages     = {6:1--6:27},
  kind      = {Journal},
  status    = {Appeared},
  core      = {A*},
  abstract  = {Many areas of computer science are concerned with some form of variation in software--from managing changes to software over time, to supporting families of related artifacts. We present the choice calculus, a fundamental representation for software variation that can serve as a common language of discourse for variation research, filling a role similar to the lambda calculus in programming language research. We also develop an associated theory of software variation, including sound transformations of variation artifacts, the definition of strategic normal forms, and a design theory for variation structures, which will support the development of better algorithms and tools.},
}

%%%%%%%%
% 2010 %
%%%%%%%%

@inproceedings{EW10foser,
  author    = {Erwig, Martin and Walkingshaw, Eric},
  title     = {{Program Fields for Continuous Software}},
  booktitle = FoSER,
  year      = 2010,
  pages     = {105--108},
  kind      = {Workshop},
  status    = {Appeared},
  rate      = {63\%},
  core      = {N/A},
  abstract  = {We propose program fields, a formal representation for groups of related programs, as a new abstraction to support future software engineering research in several areas. We will discuss opportunities offered by program fields and research questions that have to be addressed.},
}

@inproceedings{EW10vl,
  author    = {Erwig, Martin and Walkingshaw, Eric},
  title     = {{Causal Reasoning with Neuron Diagrams}},
  booktitle = VLHCC,
  year      = 2010,
  pages     = {101--108},
  kind      = {Conference},
  status    = {Appeared},
  rate      = {29\%},
  core      = {A},
  abstract  = {The principle of causation is fundamental to science and society and has remained an active topic of discourse in philosophy for over two millennia. Modern philosophers often rely on "neuron diagrams", a domain-specific visual language for discussing and reasoning about causal relationships and the concept of causation itself. In this paper we formalize the syntax and semantics of neuron diagrams. We discuss existing algorithms for identifying causes in neuron diagrams, show how these approaches are flawed, and propose solutions to these problems. We separate the standard representation of a dynamic execution of a neuron diagram from its static definition and define two separate, but related semantics, one for the causal effects of neuron diagrams and one for the identification of causes themselves. Most significantly, we propose a simple language extension that supports a clear, consistent, and comprehensive algorithm for automatic causal inference.},
}

@inproceedings{W10vld,
  author    = {Walkingshaw, Eric},
  title     = {{Managing Variation in Explanation-Oriented Languages}},
  booktitle = {{Doctoral Consortium at }} # VLHCC,
  year      = 2010,
  pages     = {247--248},
  kind      = {Consortium},
  status    = {Appeared},
  abstract  = {This work considers the intersection of explanation-oriented language design and software variation management, two seemingly disparate research areas that turn out to be quite complementary. Successful explanations are often highly variable to adapt to the needs of a particular user, but this also makes them complex and unwieldy unless supported by a sound theory of variation.}
}

@incollection{qual,
  author    = {Walkingshaw, Eric},
  title     = {{Features and Feature Models: A Survey of Variation Representations}},
  booktitle = {{Compendium of Computer Science Doctoral Qualifying Exams}},
  publisher = {Oregon State University},
  year      = 2010,
  note      = {\url{http://hdl.handle.net/1957/19243}},
  kind      = {Thesis},
  status    = {Appeared},
  abstract  = {This survey explores and organizes existing work on the long-term management of software that varies in multiple dimensions. It focuses, in particular, on the representation of features in software product lines, and on capturing relationships between features in feature models.}
}

%%%%%%%%
% 2009 %
%%%%%%%%

@inproceedings{EW09vl,
  author    = {Erwig, Martin and Walkingshaw, Eric},
  title     = {{Visual Explanations of Probabilistic Reasoning}},
  booktitle = VLHCC,
  year      = 2009,
  pages     = {23--27},
  kind      = {Conference},
  status    = {Appeared},
  rate      = {29\%},
  core      = {A},
  abstract  = {Continuing our research in explanation-oriented language design, we present a domain-specific visual language for explaining probabilistic reasoning. Programs in this language, called explanation objects, can be manipulated according to a set of laws to automatically generate many equivalent explanation instances. We argue that this increases the explanatory power of our language by allowing a user to view a problem from many different perspectives.},
}

@inproceedings{WSEMT09,
  author    = {Walkingshaw, Eric and Strauss, Paul and Erwig, Martin and Mueller, Jonathan and Tumer, Irem},
  title     = {{A Formal Representation of Software-Hardware System Design}},
  booktitle = DTM,
  year      = 2009,
  pages     = {1387--1398},
  kind      = {Conference},
  status    = {Appeared},
  core      = {N/A},
  abstract  = {The design of hardware-software systems is a complex and difficult task exacerbated by the very different tools used by designers in each field. Even in small projects, tracking the impact, motivation and context of individual design decisions between designers and over time quickly becomes intractable. In an attempt to bridge this gap, we present a general, low-level model of the system design process. We formally define the concept of a design decision, and provide a hierarchical representation of both the design space and the context in which decisions are made. This model can serve as a foundation for software-hardware system design tools which will help designers cooperate more efficiently and effectively. We provide a high-level example of the use of such a system in a design problem provided through collaboration with NASA.},
}

@article{WE09jfp,
  author    = {Walkingshaw, Eric and Erwig, Martin},
  title     = {{A Domain-Specific Language for Experimental Game Theory}},
  journal   = JFP,
  volume    = 19,
  publisher = {Cambridge University Press},
  year      = 2009,
  pages     = {645--661},
  kind      = {Journal},
  status    = {Appeared},
  core      = {A},
  abstract  = {Experimental game theory is increasingly important for research in many ﬁelds. Unfortunately, it is poorly supported by computer tools. We have created Hagl, a domain-speciﬁc language embedded in Haskell, to reduce the development time of game-theoretic experiments and make the deﬁnition and exploration of games and strategies simple and fun.}
}
  

@inproceedings{EW09dsl,
  author    = {Erwig, Martin and Walkingshaw, Eric},
  title     = {{A DSL for Explaining Probabilistic Reasoning}},
  booktitle = DSL,
  series    = LNCS,
  volume    = 5658,
  year      = 2009,
  pages     = {335--359},
  note      = {\textbf{Best~paper}},
  kind      = {Conference},
  status    = {Appeared},
  rate      = {37\%},
  core      = {N/A},
  abstract  = {We propose a new focus in language design where languages provide constructs that not only describe the computation of results, but also produce explanations of how and why those results were obtained. We posit that if users are to understand computations produced by a language, that language should provide explanations to the user.  As an example of such an explanation-oriented language we present a domain-specific language for explaining probabilistic reasoning, a domain that is not well understood by non-experts. We show the design of the DSL in several steps. Based on a story-telling metaphor of explanations, we identify generic constructs for building stories out of events, and obtaining explanations by applying stories to specific examples. These generic constructs are then adapted to the particular explanation domain of probabilistic reasoning. Finally, we develop a visual notation for explaining probabilistic reasoning.},
}

@inproceedings{WE09dsl,
  author    = {Walkingshaw, Eric and Erwig, Martin},
  title     = {{Varying Domain Representations in Hagl -- Extending the Expressiveness of a DSL for Experimental Game Theory}},
  booktitle = DSL,
  series    = LNCS,
  volume    = 5658,
  year      = 2009,
  pages     = {310--334},
  kind      = {Conference},
  status    = {Appeared},
  rate      = {37\%},
  core      = {N/A},
  abstract  = {Experimental game theory is an increasingly important research tool in many fields, providing insight into strategic behavior through simulation and experimentation on game theoretic models. Unfortunately, despite relying heavily on automation, this approach has not been well supported by tools. Here we present our continuing work on Hagl, a domain-specific language embedded in Haskell, intended to drastically reduce the development time of such experiments and support a highly explorative research style.  In this paper we present a fundamental redesign of the underlying game representation in Hagl. These changes allow us to better leverage domain knowledge by allowing different classes of games to be represented differently, exploiting existing domain representations and algorithms. In particular, we show how this supports analytical extensions to Hagl, and makes strategies for state-based games vastly simpler and more efficient.},
}

%%%%%%%%
% 2008 %
%%%%%%%%

@inproceedings{EW08vl,
  author    = {Erwig, Martin and Walkingshaw, Eric},
  title     = {{A Visual Language for Representing and Explaining Strategies in Game Theory}},
  booktitle = VLHCC,
  year      = 2008,
  pages     = {101--108},
  kind      = {Conference},
  status    = {Appeared},
  rate      = {29\%},
  core      = {A},
  abstract  = {We present a visual language for strategies in game theory, which has potential applications in economics, social sciences, and in general science education. This language facilitates explanations of strategies by visually representing the interaction of players' strategies with game execution. We have utilized the cognitive dimensions framework in the design phase and recognized the need for a new cognitive dimension of "traceability" that considers how well a language can represent the execution of a program. We consider how traceability interacts with other cognitive dimensions and demonstrate its use in analyzing existing languages. We conclude that the design of a visual representation for execution traces should be an integral part of the design of visual languages because understanding a program is often tightly coupled to its execution.},
}

@inproceedings{W08vld,
  author    = {Walkingshaw, Eric},
  title     = {{Designing Explanation-Oriented Languages}},
  booktitle = {{Doctoral Consortium at }} # VLHCC,
  year      = 2008,
  pages     = {274--275},
  kind      = {Consortium},
  status    = {Appeared},
  abstract  = {We are developing a new paradigm of explanation-oriented languages whose objective is not only to describe the computation of values, but also to provide explanations of how and why those values are obtained. We have begun exploring this approach in the design of a visual notation for strategies in game theory. We plan to apply these ideas to other domains of public interest to both benefit those domains and to expand and solidify the theory behind explanation-oriented design.}
}
