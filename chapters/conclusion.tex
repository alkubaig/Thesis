Integrating variation with side effects does not have a one-size-fits-all solution because each effect requires a special treatment and the solution for one effect might be incompatible with other effects. The best solution given the constraints is to solve this problem at the library level giving the programmer the tools to deal with the interaction of variation and effects. As a proof-of-concept, we use algebraic effects to encode variation as an effect. Then, extend the execution environment of variational programs to support file I/O. Algebraic effects allow programmers to handle new types of effects or handle the existing effects in multiple ways. This makes them highly complementary with variational programs. As part of our contribution, we implement an abstract variational queue, which is a variational data structure that could be used in many applications of variational programming to incorporate variational data collections. 

For future work, we could extend the execution environment of variational programs to handle new types of effects such as mutable states, standard input/output, and exceptions. We could also handle file I/O differently. For example, we could create a new file instance for every context initiated in the variational program. The name of every file instance corresponds to its context. We already showed a simulation of this in Chapter \ref{sec:introduction}. Our potential goal of this work is to include both algebraic effects and built-in support for variation in languages. That is, built-in constructs for choices and optional values, and corresponding language run-time support for variational execution. This would properly perform variational execution with side effects.

% The library is an extension to the languages and could be further advanced to deal with more effects on a case-by-case basis. This paper presents a proof-of-concept prototype for integrating variation with side effects in file I/O. We use algebraic effects and handlers to implement this work. We encode variation as an effect. Then, extend the library with new handlers that work with file I/O reading and writing. This makes our work orthogonal because the language is independent of its exertions. For example, the variation effect stands on its own without the effect-aware extensions, and so on. This work presents the basic idea that could be done for other types of effects. To make this work in file I/O more powerful and to keep the preservation property hold, we introduced a new file format that extends the plain file format with variation. Other work in \cite{Austin14} has dealt with the integration of variation and file I/O without altering the files. However, this makes their work more limited and breaks the preservation property as discussed in Section \ref{related_work2}. We hope that our proposed solution would be used in better settings to cope with the efficiency problems caused by the limited features of the language \emph{Eff} and the fact that variation is implemented as an external library. If variation was built-in into the language, we could design better ways to improve efficiency in variational programs.